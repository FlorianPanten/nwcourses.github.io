<!DOCTYPE html><html><head><link rel='stylesheet' type='text/css' href='../css/dfti0910.css' /></head><body><p><!DOCTYPE html>
<html>
<head>
<title>Week 6 - Further A-Frame</title>
<link rel='stylesheet' type='text/css' href='../css/dfti0910.css' /></p>
<p></head>
<body></p>
<div class='titlebox'>
<h1>Immersive Technologies</h1>
<h2>Topic 6: Further A-Frame</h2>
</div>
<h2>This week</h2>
<p>We are doing:
    <ul>
    <li>Further A-Frame: dynamically creating entities, models in A-Frame, text.</li>
    <li>Using three.js with A-Frame</li>
    </ul>
</p>
<h2>Dynamic Creation of Components with A-Frame</h2>
<p>We are now going to look at how we can <em>dynamically create entities and
components using A-Frame</em> and the DOM. So far, our entities and components 
have been hard-coded in HTML. However in many cases, we might want to 
dynamically build a scene based on data sent back, in JSON for example, from
the web. Most augmented reality apps would work this way: the augmented 
content would not be hard-coded but downloaded from a server. For example,
points of interest in an AR or VR POI app would be downloaded from a server
and in Pokemon Go the locations of the Pokemon are also downloaded. So we
need to know how to dynamically generate content in A-Frame.</p>
<p>In the DOM notes we looked at <code>document.createElement</code> So,
we can use <code>document.createElement()</code> here to dynamically create
our A-Frame content. Here is an example:
<pre>
AFRAME.registerComponent('dynamic-content-loader', {
    init: function() {
        // Create an entity with document.createElement()
        const entity = document.createElement('a-entity');

        // Add a geometry component to it (a box primitive)
        entity.setAttribute('geometry', {
            primitive: 'box'
        });

        // Add a material component to it (red colour)
        entity.setAttribute('material', {
            color: 'red'
        });

        // Set its position within the 3D world
        entity.setAttribute('position', {
            x: 0,
            y: 1,
            z: -5
        });

        // Append the entity to the scene (this.el.sceneEl)
        this.el.sceneEl.appendChild(entity);
    }
});
</pre>
which would be used along with an A-Frame scene such as that below:
<pre>
&lt;a-scene dynamic-content-loader&gt;
&lt;a-sky color="skyblue"&gt;&lt;/a-sky&gt;
&lt;a-plane color='green' position='0 0 0' rotation='-90 0 0' width='100' height='100'&gt;&lt;/a-plane&gt;
&lt;/a-scene&gt;
</pre>
What is this doing?
    <ul>
    <li>We are definining a component called <code>dynamic-content-loader</code>.
    </li>
    <li>Within this component we create an <code>a-entity</code> dynamically using DOM, and set its <code>geometry</code>, <code>material</code> and <code>position</code> components.</li>
    <li>Then we <em>append</em> the entity we've just created to the A-Frame <em>scene</em>. Note how we can access the A-Frame scene from any entity using <code>this.el.sceneEl</code>. Whereas <code>this.el</code> represents the current entity, <code>this.el.sceneEl</code> represents the scene as a whole. So the entity we've dynamically created will be a child of our <em>scene</em>. (In this case, the component is attached to the scene anyway, but referencing <code>this.el.sceneEl</code> would allow the code to work even if the component was being attached to some other entity)</li>
    </ul>
</p>
<p>This example is just a simple example of creating dynamic content, but
you could use a component like this to load JSON over AJAX and then create
content based on parsing the JSON.</p>
<h2 id="models">Models</h2>
<p>We are now going to consider how to load models in A-Frame.</p>
<h3 id="howtoincludeamodelinanaframeapplication">How to include a model in an A-Frame application</h3>
<p>The first thing to note is that models can be rather large files. If our
application is creating many instances of entities all using the same model
(e.g. many monsters in a game) you do not want to load the same model over 
and over again because this will be very inefficient. Instead, we want to load
the model <em>once</em>, on startup, and then reference the <em>loaded</em> model when we
create our entities. Luckily we can do this in A-Frame by making use of 
A-Frame <em>assets</em> (the <code>&lt;a-assets&gt;</code> tag).</p>
<p>Here is an example of <code>&lt;a-assets&gt;</code>. Note that the <code>&lt;a-assets&gt;</code> are contained
within your <code>&lt;a-scene&gt;</code>.</p>
<pre><code>&lt;a-assets&gt;
&lt;a-asset-item src='assets/cow.obj' id='cow'&gt;&lt;/a-asset-item&gt;
&lt;a-asset-item src='assets/pig.obj' id='pig'&gt;&lt;/a-asset-item&gt;
&lt;a-asset-item src='assets/cow.mtl' id='cow-material'&gt;&lt;/a-asset-item&gt;
&lt;a-asset-item src='assets/pig.mtl' id='pig-material'&gt;&lt;/a-asset-item&gt;
&lt;a-asset-item src='assets/horse/scene.gltf' id='horse'&gt;&lt;/a-asset-item&gt;
&lt;/a-assets&gt;
</code></pre>
<p>There are four assets here, two OBJ models of a cow and a pig, and two
accompanying <code>.mtl</code> (material) files. Material files describe the properties of
the material used for the model, including its colour and its reflective
properties. The <code>.mtl</code> file will also contain a link to a texture image
(e.g. a PNG image), if one is provided. Note how generic assets, such as 
models, are specified using <code>&lt;a-asset-item&gt;</code>.
Note also how each asset has an ID; this will be used when we
create an entity using that asset later.</p>
<h4 id="howwewouldreferenceanassetinourcode">How we would reference an asset in our code</h4>
<p>Here is how we could reference an asset in our code:</p>
<pre><code>&lt;a-entity obj-model='obj: #cow'&gt;&lt;/a-entity&gt;
</code></pre>
<p>This is creating an entity which will represent an OBJ model, hence the
<code>obj-model</code> component. The <code>obj-model</code> component contains a property <code>obj</code> 
whose value is <code>#cow</code>, which references the asset with the ID of <code>cow</code>.</p>
<p>To link the <code>.mtl</code> (material) asset, we use the <code>mtl</code> property, e.g:</p>
<pre><code>&lt;a-entity obj-model='obj: #cow; mtl: #cow-material'&gt;&lt;/a-entity&gt;
</code></pre>
<p>As well as OBJ, we can handle GLTF with the <code>gltf-model</code> component, e.g this
<code>gltf-model</code> is using an asset with an ID of <code>horse</code>:</p>
<pre><code>&lt;a-entity gltf-model='#horse'&gt;&lt;/a-entity&gt;
</code></pre>
<p>We can of course also dynamically create our entities from JavaScript, for
example:
<pre>const entity = document.createElement('a-entity');

// Add the obj-model component. This will simply reference the ID of the asset
// as its 'obj' property.
entity.setAttribute('obj-model', {
    obj: '#cow',
    mtl: '#cow-material'
});
</pre>
</p>
<h2 id="text">Text</h2>
<p>We can create text in A-Frame, using 
an <code>&lt;a-entity&gt;</code> with a <code>text</code> component. The <code>text</code> component has various
properties, the most important being the <code>value</code> - the actual text. See
<a href="https://aframe.io/docs/1.0.0/components/text.html">the A-Frame documentation</a>
for details.  By default, text is rather small, so it needs to be scaled to 
make it visible (scaling up by 100 gives a usable size).</p>
<pre><code>entity.setAttribute('text', {
    value: 'Some text'
});
entity.setAttribute('scale', {
    x: 100,
    y: 100,
    z: 100
});
</code></pre>
<h3 id="lookingatthecamera">Looking at the camera</h3>
<p>By default, text will look towards positive z however this isn't necessarily
what we want. We more commonly want the text to <em>look at the camera</em> so that
it's always visible. To do this we make use of the third-party <code>look-at</code>
component. To use <code>look-at</code> you need to include it as a dependency in your package.json:</p>
<pre>"dependencies": {
    "aframe-look-at-component": "^1.0.0",
    ...other dependencies...
}</pre>
and import it into your code:
<pre>import 'aframe-look-at-component';</pre>
<p>then you can add it to an entity e.g:</p>
<pre><code>&lt;a-entity text='value: Hello World' scale='100 100 100' look-at='[camera]'&gt;&lt;/a-entity&gt;
</code></pre>
<p>Note how in this example the text is looking at the camera. We specify the camera with the square brackets syntax <code>[camera]</code>. (Square brackets
in CSS select any element with that attribute present. In A-Frame this is equivalent to selecting an entity with the given component present. So here, we are selecting the entity which contains the <code>camera</code> component, i.e. our camera entity). We can, as an alternative, look at any other entity in our scene by specifying an appropriate CSS selector.</p>
<h3 id="othertextproperties">Other text properties</h3>
<p>See <a href="https://aframe.io/docs/1.0.0/components/text.html">the A-Frame documentation</a>. Other properties you can set on the <code>text</code> component include:</p>
<ul>
<li><code>align</code>: horizontally justifying the text (left, center or right);</li>
<li><code>baseline</code>: specifying the baseline of the text (top, center or bottom) - 
i.e. will the top, the centre or the bottom of the text be placed at the
<code>y</code> coordinate?</li>
</ul>
<h3 id="positioningtextonaplane">Positioning text on a plane</h3>
<p>A common use-case is to position text on an existing plane, for example to
draw a noticeboard or signpost. What you can do here is to create an 
<code>&lt;a-plane&gt;</code> with a <code>text</code> component. e.g.</p>
<pre><code>&lt;a-plane text='value: Hello' material='color: red' width=4 height=1 look-at='[camera]'&gt;&lt;/a-plane&gt;
</code></pre>
<p>Note how the <code>&lt;a-plane&gt;</code> has a material, a width and a height - but also has
its own <code>text</code> component. This will draw the text directly on the plane.
The text is automatically scaled to fit on the plane, though by default the
text will be very small. You can, however, use the <code>wrapCount</code> property of
the <code>text</code> component to specify approximately how many characters will fit on 
the plane, for example if you set <code>wrapCount</code> to 20, the text will scale to
a size where it would exactly fit on the plane if it contained 20 characters.
Any characters beyond the <code>wrapCount</code> will appear on the next line.</p>
<h3 id="internationalcharacters">International characters</h3>
<p>Note that A-Frame text will <em>not</em> by default work with international character sets. Only characters present in a given font will be renderered (drawn) and for the default font used by A-Frame, these are just the standard ASCII characters. The font format used is known as the <em>MSDF</em> format. If you wish to render international characters, you need to use an online font-generator such as <a href="https://msdf-bmfont.donmccurdy.com">Don McCurdy's font generator</a>. To use this, you upload a TrueType (<code>.ttf</code>) font containing your chosen characters to this site, and it will generate a MSDF font for those characters. This consists of two files: </p>
<ul>
<li>a JSON file defining the font properties,</li>
<li>and a PNG image containing the actual characters. </li>
</ul>
<p>These can then be used to render text by 
setting the <code>font</code> and <code>fontImage</code> properties of the <code>text</code> attribute to the
JSON file and PNG image respectively.</p>
<h2 id="usinginaframe">Using three.js in A-Frame</h2>
We now going to look at how we can use three.js features within A-Frame. A key point is that all A-Frame entities have an <code>object3D</code> property, which references the underlying three.js <code>Object3D</code> (this could, as we have seen, be - amongst other things - a mesh, a camera or a light… essentially anything with the ability to be positioned, rotated and scaled).</p>
<p>This allows us to change properties such as position, scale, rotation more efficiently than updating the DOM attributes, as we have done before. As we have seen, the three.js <code>Object3D</code> has various useful methods available which will efficiently translate, rotate or scale the object. So to perform such transformations on A-Frame entities, it is strongly recommended to use the <code>Object3D</code> methods as these are efficient, rather than the DOM manipulations (retrieving and altering the <code>position</code> and <code>rotation</code> properties for example) that we have done up to now. DOM manipulations involve parsing the data and are slower - we have used them up to now because they are simple and do not require any three.js understanding. </p>
<p>We can also do things like create a new <code>&lt;a-entity&gt;</code>, create an <code>Object3D</code> with three.js (e.g. a mesh, a camera or a light), and attach the  <code>Object3D</code> to the entity using the entity's <code>setObject3D()</code> method.</p>
<pre>const entity = document.createElement('a-entity'); 
const geom = new THREE.BoxGeometry(2, 2, 2);
const mesh = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({ color: 0xff0000 } ));
mesh.position.z = -10;
entity.setObject3D('mesh', mesh);
</pre>
<p>This code should hopefully be fairly obvious. We create an A-Frame entity,
then a three.js mesh, and attach it to the entity. Note that <code>setObject3D()</code> takes two arguments, an identifier for the <code>Object3D</code> we are attaching, plus the <code>Object3D</code> itself. (It is possible to attach multiple <code>Object3D</code>s to an entity).</p> <p>To access the <code>Object3D</code> associated with an entity, you can use the entity's <code>object3D</code> property. Once you have this, you can use any of the properties
or methods of three.js's <code>Object3D</code>, see the documentation <a href="https://threejs.org/docs/index.html#api/en/core/Object3D">here</a>. For example, to rotate an entity by 45 degrees around the Y axis:</p>
<pre>
// use DOM to get entity
const entity = document.getElementById('entity1'); 

entity.object3D.rotateY(THREE.MathUtils.deg2rad(45));
</pre>
<p>Essentially the <em>whole three.js API</em> is available within an A-Frame application. Once you understand the relationships between A-Frame and three.js (the <code>object3D</code> is perhaps the most important), this allows you to build pure three.js features into an A-Frame application. There are other relationships, regarding the <code>&lt;a-scene&gt;</code> entity, which are useful to know, too: </p>
<ul>
<li>the <code>object3D</code> of the <code>&lt;a-scene&gt;</code> gives, perhaps predictably, the <code>THREE.Scene</code>;</li>
<li>the <code>camera</code> property of the <code>&lt;a-scene&gt;</code> gives you the Three.js camera being used; </li>
<li>and the <code>renderer</code> property of the <code>&lt;a-scene&gt;</code> gives you the Three.js <code>WebGLRenderer</code> being used.</li>
</ul>
<h3 id="camerasandlightsinaframe">Cameras and lights in A-Frame</h3>
<p>It should be noted that the default A-Frame scene comes with a perspective camera and two lights (an ambient light and a directional light) already added.
See the A-Frame docs <a href="https://aframe.io/docs/1.0.0/components/camera.html#default-camera">here for the default camera</a> and <a href="https://aframe.io/docs/1.0.0/components/light.html">here for default lighting</a>.  If you add your own camera with <code>&lt;a-camera&gt;</code>, or <code>&lt;a-entity camera&gt;</code>, (&lt;a-camera&gt; is basically a short cut for &lt;a-entity camera&gt; i.e. an entity with a camera component) then the default camera is not added.</p>
<p>Note that there is a slight difference between using an <code>&lt;a-entity&gt;</code> with the <code>camera</code> component added (<code>&lt;a-entity camera&gt;</code>) versus using the <code>&lt;a-camera&gt;</code> primitive. <code>&lt;a-camera&gt;</code> automatically adds some further components to the camera, including <code>look-controls</code> (the ability to look around with the mouse or by moving a mobile device) and <code>wasd-controls</code> (the ability to move the camera with the WASD-keys). See <a href="https://aframe.io/docs/1.0.0/primitives/a-camera.html#sidebar">the documentation</a></p>
<p>The default lights in A-Frame are:</p>
<ul>
<li>an ambient light with a slightly greyish white (hex code #BBB)</li>
<li>a directional white light with intensity 0.6. This has a position of
x=0.5, y=1, z=1, which means that (like the three.js lights, which the
A-Frame lights wrap) the light shines towards the origin from this
position. So it will shine from behind, and slightly to the right of, the user in the default A-Frame view (remember that by default the camera faces
negative <code>z</code>).</li>
</ul>
<p>You can also easily add additional lights in an A-Frame scene by adding
<code>light</code> components to entities, e.g:</p>
<pre><code>&lt;a-entity light='type: directional; position: 0 1 0; color: #ffff00; intensity: 0.5'&gt;&lt;/a-entity&gt;
&lt;a-entity light='type: directional; position: -1 0.5 0; color: #0000ff; intensity: 1.0'&gt;&lt;/a-entity&gt;
</code></pre>
<p>As decribed in the documentation, you can turn the default lighting off by 
setting a <code>light</code> component on the <code>&lt;a-scene&gt;</code> with the property <code>defaultLightsEnabled</code> set to <code>false</code>:</p>
<pre><code>&lt;a-scene light='defaultLightsEnabled: false'&gt;
</code></pre>
<!--
<h3 id="exercise3">Exercise - A-Frame with three.js</h3>
<ol>
<li>Return to last weeks' work - the exercise which involved ?????. Rewrite the JavaScript code so that you create a <code>THREE.Mesh</code> for each entity and attach the mesh to the entity. Also set the mesh's position using raw three.js.  </li>
<li>Change the <code>vertical-controls</code> component from Week 5 so that it updates the <code>y</code> coordinate of the camera using <code>Object3D</code>'s <code>translateY()</code> method, rather than updating the <code>position</code> via the DOM. Add the <code>vertical-controls</code> component to your scene from question 1, above.</li>
<li>Create a tetrahedron geometry in three.js in the same way as the pentagon example above.  A tetrahedron is made up of a triangular base and three triangular sides - in other words, four faces in total. See below:</p></li>
<p><img src="images/tetrahedron.png" alt="Tetrahedron" /></p>
<p>Use the following coordinates for each vertex:</p>
<ul>
<li>Vertex 1: -0.5, 0, 0.5</li>
<li>Vertex 2: 0.5, 0, 0.5</li>
<li>Vertex 3: 0, 0, -0.5</li>
<li>Vertex 4: 0, 1, 0 (this is the 'top')</li>
</ul>
TODO show how to do this!
</li>
</ol>
<p>Add some tetrahedrons to your scene in questions 1 and 2 by creating some
meshes from this geometry and attaching them to <code>&lt;a-entity&gt;</code>s.</p>
<h3>Advanced!</h3>
<ol start="4">
<li>Research normals on three.js (see the <a href="https://threejs.org/docs/index.html#api/en/core/Face3">Face3 documentation</a>). Calculate normals for each face of your tetrahedron.  Alter your scene so that the default A-Frame lights are not included and instead add the lights below to your scene. Also use a black <code>&lt;a-sky&gt;</code> to give an impression of night.</li>
</ol>
<ul>
<li>a white ambient light, intensity 0.2</li>
<li>a white directional light, intensity 1.0, shining from y=1, z=1.</li>
</ul>
<p>Do you get the lighting effect you expect?</p>
-->
</body></html>
