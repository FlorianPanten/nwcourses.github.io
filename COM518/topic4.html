<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Topic 6: Further AJAX: POST requests, DOM</title>
<link rel='stylesheet' type='text/css' href='../css/dfti0910.css' />
</head>
<body>
<h1>Topic 6: Further AJAX</h1>
<h2>Introduction</h2>
<p>Last week we looked at AJAX and saw how to develop an AJAX front-end to
a web API which sends GET requests to the API and parses the JSON returned.
This week we will extend upon that by looking at how we can send <em>POST</em>
requests to a web API and use the <em>Document Object Model (DOM)</em> to
dynamically manipulate the page.</p>
<p>Specifically, we will look at:
    <ul>
    <li>How to retrieve an HTTP status code from an AJAX client;</li>
    <li>How to send POST requests from an AJAX client</li>
    <li>The Document Object Model (DOM)</li> 
    </ul>
</p>
<h3>How to test the HTTP status code from an AJAX client</h3>
<p>It is easy to test the HTTP status code from a web service client. If you are using AJAX you can simply use
the <em>status</em> property of the <em>response</em> object. For example, this
code will test for a 404: 
<pre>const response = await fetch('https://example.com/product/223');
if(response.status == 404) {
    alert("The product was not found!");
} else {
    const data = await response.json();
    // etc...
}</pre>
</p>
<h3>POST requests from AJAX</h3>
<p>To send POST requests from AJAX, you need to create a POST request from
the fetch API and specify the data you want to send and the <code>Content-Type</code> header, much like you do in RESTer. Here is a code snippet which will send
a POST request to a <code>/newproduct</code> endpoint:
<pre>const product = {
    name: "Cornflakes",
    manufacturer: "Organic Products Ltd",
    price: 2.79
};

const response = await fetch('https://example.com/products/newproduct', {
    method: 'POST',
    headers: {
        'Content-Type' : 'application/json'
    },
    body: JSON.stringify(product)
});</pre>
Note how we send a <code>fetch()</code> request to the given URL, but this
time, we have to specify a number of options in a JavaScript object as a second argument to the <code>fetch()</code> function. These are:
    <ul>
    <li>the HTTP method (POST here);</li>
    <li>the HTTP headers we want to add to the request. This is itself a JavaScript object containing a series of property/value pairs, the properties being the header name and the value, its value. So here, we are setting the <code>Content-Type</code> header to <code>application/json</code>.</li>
    <li>The request body. This is a JSON string representing the data we want to send. Note that here, we create the JSON by specifying a JavaScript object <code>product</code>, containing product details, and then convert it to a JSON string with <code>JSON.stringify()</code>.
    </li>
    </ul>
<h2>Querying and Manipulating HTML documents using the DOM</h2>
<p>
Previously you've seen the <em>innerHTML</em> property which can be used to read, or change, the text within an HTML element. You've also looked at simple use of the <em>Document Object Model (DOM)</em> to access elements on a web page -
specifically the use of <em>getElementById()</em> to access a specific 
page element using its ID.</p>
<p> However that's just the start: the DOM offers a whole range of ways to read and manipulate HTML pages or XML data. To understand how you can use DOM for document manipulation, you must understand the concept of <em>nodes</em>, which we will discuss below.  The examples below use the DOM to manipulate HTML documents, however, more generally, the DOM is used for accessing and manipulating XML documents. An HTML web page is a particular, specific type of XML document. So, as well as using the DOM to query and manipulate web pages, we can use it in a more general sense to query and manipulate XML. In AJAX, this latter use of the DOM is used extensively.</p> 

<h3>The Concept of Nodes</h3>
<ul>
<li>Part of the W3C Document Object Model (DOM)</li>
<li>A systematic way to navigate and manipulate the content of an HTML or XML document, not
only the <em>elements</em>, but also the <em>text within them</em></li>
<li>An HTML or XML document consists of a series of hierarchical <em>nodes</em></li>
<li>Each <em>element</em> (e.g <em>p</em>, <em>div</em>, or <em>em</em>
in HTML; or a custom tag in XML) is treated as a <em>node</em>
</li>
<li>However it's not just the elements themselves:
the <em>text</em> within each element is also treated as a special kind of node, a <em>text node</em></li>
<li>The nodes are a <em>nested</em>, <em>hierarchical</em> structure</li>

    <ul class="subpoint">
    <li>An element within an element is a <em>child node</em> of that element
    </li>
    </ul>

</ul>
<h3>Example of Nodes Terminology</h3>
<pre>&lt;body&gt;

&lt;p&gt; Welcome to the <em>&lt;em&gt;wonderful!&lt;/em&gt;</em> world of dynamic text!&lt;/p&gt;
&lt;/body&gt;
</pre>

<li>The paragraph is a <em>child node</em> of the <em>body</em></li>

<li>The paragraph contains <strong>three</strong> of its own <em>child nodes</em>:</li>
    <ul>    
    <li>The <strong>text</strong>: <em>"Welcome to the"</em></li>
    <li>The <strong>em</strong> element</li>

    <li>The <strong>text</strong>: <em>"world of dynamic text!"</em></li>
    </ul>

<li>The <strong>em</strong> <em>itself</em> contains one child node:
    <ul>
    <li>The <strong>text</strong>: <em>"wonderful!"</em></li>

    <li>This is a child of the <strong>em</strong> not the 
    <strong>p</strong></li>
    </ul>
</li>

<!--
<h3>Nodes Hierarchy Diagram: Nested view</h3>
<pre>&lt;body&gt;
&lt;p&gt; Welcome to the <em>&lt;em&gt;wonderful!&lt;/em&gt;</em> world of dynamic text!&lt;/p&gt;

&lt;/body&gt;
</pre>
<img src="../images/nodes.png" alt="Nodes" /> <br />
-->
<h3>Nodes Hierarchy Diagram: Tree view</h3>
<pre>&lt;body&gt;
&lt;p&gt; Welcome to the <em>&lt;em&gt;wonderful!&lt;/em&gt;</em> world of dynamic text!&lt;/p&gt;

&lt;/body&gt;
</pre>
<img src="../images/nodes2.png" alt="Nodes" /> <br />
</p>
<h3>Adding a new node</h3>
<ul>
<li>One of the keys to dynamic text</li>
<li><em>document.createElement()</em> allows us to <em>create a brand
new element!</em></li>

<li><em>document.createTextNode()</em> allows us to create a brand new
text node</li>
<li>Having created an element we can then populate it with text nodes
and child elements</li>
<li>... and finally add it to either:
    <ul>
    <li>The body</li>
    <li>Another element, which will act as its parent</li>
    </ul>
</li>

</ul>
<p>
<a href="examples/dom/node_add.html">Example</a>
</p>
<h3>Replacing an existing node</h3>
<ul>
<li>The other key to dynamic text</li>
<li>We can <em>replace a whole paragraph of text with another!!!</em></li>
<li>Steps:
    <ul>
    <li>Find the element to replace</li>
    <li>Create a new element (as per the previous example)</li>

    <li>Call <em>replaceChild()</em> to replace the old
    node with the new</li>
    </ul>
</li>
</ul>
<p><a href="examples/dom/node_replace.html">Example</a></p>
<h3>Getting all elements of a particular type</h3>
<ul>
<li>It can make it easier to find a page element if we can collect
together all elements of a particular type (e.g. all paragraphs)</li>

<li><em>document.getElementsByTagName()</em> allows us to do this
</li>
<li>This gives us an <em>array</em> of all elements of a particular
type, which we can then index</li>

</ul>

<p><a href="examples/dom/bytagname.html">Example</a></p>
<h3>Removing nodes</h3>
<ul>

<li>The final key concept of dynamic text is <em>removing</em> a particular
node</li>
<li>Use 
<pre>parentElement.removeChild(childElement)
</pre>
</li>
<li>Use IDs or <em>getElementByTagName()</em> once again to find
the element to remove</li>
</ul>

<h3>Other useful features of the DOM</h3>
<p>(Source:
<a href='http://www.quirksmode.org/dom/w3c_core.html'>Quirksmode</a>, a very useful reference site for JavaScript
and the DOM)</p>

<ul>
<li><em>childNodes</em> property - an array of all the child nodes of a given node.e.g.:
<pre>
parent.childNodes.forEach ( childNode =&gt; {
    alert(childNode.nodeName); // show name of the node
});
</pre>
</li>
<li><em>firstChild</em> and <em>lastChild</em> properties - the first and last 
child node of a given node. e.g.
<pre>

// create a child node of the parent, assume that 'parent' has no children yet
var p = document.createElement("p");
parent.appendChild(p);

// create a text node
var textNode = document.createTextNode("some text");

// append it to the first child of the node 'parent', which will be the
// paragraph we created above. In other words 'p' and 'parent.firstChild'
// are the same in this case.
parent.firstChild.appendChild(textNode);
</pre>
</li>
<li> <em>document.querySelector()</em> 
and <em>document.querySelectorAll()</em> give the first
element, and all elements, which match a CSS selector respectively, eg
<pre>document.querySelectorAll(".important")</pre>
will give an array of all elements with a class of <em>important</em>.
See <a href="examples/dom/selector.html">Example</a></p>
</li>
</ul>
<h3>Inspecting elements</h3>
<p>The <em>inspect</em> functionality in the browser will help you see
what's going on - try it as you do the exercise for this week - right click on an element. Inspecting helps you to see the actual current DOM structure of the
page - including any dynamically-created elements.</p>
<h2>Exercise</h2>
<p>The main exercise is to add "Buy" functionality to your AJAX front-end
fron last week, so that a user can buy a given song. Songs will be bought by sending an AJAX POST request to the "buy" route of your web API.</p>
<p>Modify your AJAX front-end so that there is a "Buy" button for each search result. When the user clicks on the "Buy" button, you should call another function which sends an AJAX POST request to your "buy" route from week 3. You can do this by:
<ul>
<li>Creating a button using the DOM;</li>
<li>Using <code>addEventListener()</code> to add an event handler to the button;</li>
<li>In the event handler, send a POST request to the server including the song id</li>
</ul>

Initially, do this by adding the button to the HTML string and setting an <code>onclick</code> property on the button which calls a new <code>buy()</code> function, for example:
<pre>html += `&lt;input type='button' value='Buy!' onclick='buy(${the song ID from the JSON})' /&gt;`;</pre>
Then, write a <code>buy()</code> function in your client-side JavaScript, which takes the song ID as a parameter and sends an AJAX POST request to your Buy route on your web API:
<pre>
async function buy(songID) {
    // ... AJAX POST request - for you to complete
}
</pre>
</p>
<p> 
<h2>Binding</h2>
<p><strong>Put something on binding here.</strong></p>
<h2>Named callback functions</h2>
<p>So far, we have been mostly using anonymous arrow functions as our 
callbacks. </p>
<h3>Subtleties with "this"</h3>
<p>There are a number of subtleties with JavaScript <em>this</em> which you need to understand to work
effectively with objects, and which make its use
less straightforward than the use of <em>this</em> in other languages such as Java and C++. <strong>These subtleties are particularly important when it
comes to callbacks.</strong></p>
<h3>"this" and the window object</h3>
<p>Firstly, what does <em>this</em> refer to if it is not being used in the context of an object?
For example, if the function below was run, what would be displayed?
<pre>
function thisTest()
{
    alert(this);
}
</pre>
On Firefox it displays:
<pre>[object Window]</pre>
The output demonstrates what <em>this</em> refers to when out of the context of an object. It refers to a <em>"default object"</em> which in a web browser is the <em>window</em> object, representing
the browser window as a whole. So the example below would work too:
<pre>
function thisTest()
{
    window.alert("alert is actually a method of the window object!");
    this.alert("... and here, *this* refers to the window so this works too!");
}
</pre>
Both alerts are displayed. <em>alert()</em> is actually a method of the window object, but because
the window object is the environment's "default" object, we can normally leave <em>window</em> out;
it's included here just to illustrate the point. And
because <em>this</em> also refers to the window object in this context, the second alert will be
displayed too.</p>
<h3>"this" and callbacks - the problem</h3>
<p>The problem most commonly encountered with "this" is 
when it is being used in a <em>callback function</em>. As we have
seen, a <em>callback function</em> is a function that does not run immediately,
but at a later time, when some event has occurred (such as the user clicking a button,
or the response from an AJAX request is received). So imagine we had a Cat and we wanted it to meow if
we pressed a button, e.g:
<pre>
// cat.js
class Cat 
{

    constructor(n,a)
    {
        this.theName=n;
        this.age=a;
    }

    meow()
    {
        alert(`${this.theName} says meow!`);
    }
}



// Create the cat
const tom = new Cat("Tom", 7);

// When the user clicks the button, the meow method will run
document.getElementById("meowbtn").addEventListener("click", tom.meow);

</pre>
HTML:
<pre>
&lt;html&gt;
&lt;head&gt;
&lt;script type='text/javascript' src='cat.js'&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type='button' id='meowbtn' value='Meow!' /&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</p>
<p>If you try this out, and click the button, does the expected output:
<pre>Tom says Meow!</pre>
occur? No. Instead, you will get something like:
<pre>undefined says Meow!</pre>
Why is this happening? 
<ul>
<li>On a simple level, it is because <em>callback functions do not keep track of the object that
the method relates to.</em> So when we click the button, the meow function will be called but
the fact that it relates to the object <em>tom</em> is not retained. So when we try to display
<em>theName</em> of the current object, we get <em>undefined</em> because the current object
is not <em>tom</em> and hence has no <em>theName</em> property</li>
<li>To explain in more depth: <em>when we are using a callback function, the context of
the function changes</em>. In this example, we are basically setting the <em>click</em>
event handler of the button to be the meow method of the object <em>tom</em>. But the object
<em>tom</em> itself is <em>not</em> copied across. Instead, the code in <em>meow()</em> is copied
across to the button object, and becomes the <em>click</em> method of the button object. So,
when we click the button, <em>this</em> is actually the button object! Buttons do not have a
<em>theName</em> property, so we get <em>undefined</em>.</li>
<li>Note that <em>arrow functions always preserve the context of this</em>
so we don't have the same sort of problem if we use an arrow function as a 
callback. However, frequently we want to make a method of a class or object a callback function, as 
we have done here. In these cases, we are forced to deal with the
the "context of this" problem and ensure that <em>this</em> refers to
the correct object in the callback.</li>
</ul>
</p>
<h2>Dealing with "this" issues in callbacks with bind()</h2>
<p>Luckily, the issue is easy to deal with.
You can simply use the <em>bind()</em> method.
<em>bind()</em> does what it says on the tin: it binds the callback function to the specified
object, so that when the callback is called, <em>this</em> will refer to the correct object.
So to rewrite our Cat example so they work correctly:
<pre>
class Cat 
{

    constructor(n,a)
    {
        this.theName=n;
        this.age=a;
    }

    meow()
    {
        alert(`${this.theName} says meow!`);
    }
}


// Runs when the page loads

// Create the cat
const tom = new Cat("Tom", 7);

// When the user clicks the button, the meow method will run
    document.getElementById("meowbtn").addEventListener("click", <em>tom.meow.bind(tom)</em>);

</pre>
</p>
<p>Note how the callback <em>tom.meow()</em> is now <em>bound</em> to the
object <em>tom</em>. This means that <em>this</em> will refer to the correct
object, <em>tom</em>, when <em>tom.meow()</em> is called as a callback on
response to a button click, or indeed any other event.</p>

<h3>bind() and arguments</h3>
<p>You can specify arguments to be sent to a bound function. 
For example, imagine we wanted to make the cat walk a certain distance
when the user clicks a button. We need to make the <em>walk()</em> method 
a callback (and therefore, use <em>bind()</em>) but we also need to
pass in the distance to walk. How can we do this?
<pre>
class Cat 
{

    constructor(n,a,w)
    {
        this.theName=n;
        this.age=a;
        this.weight=w;
    }

    meow()
    {
        alert(`${this.theName} says meow!`);
    }

    walk(d) 
    {
        this.weight -= d;
    }    
}


// Create the cat
const tom = new Cat("Tom", 7, 50);

// When the user clicks the button, the walk() method will run
// and will take an argument of 5
document.getElementById("walkbtn").addEventListener("click", <em>tom.walk.bind(tom, 5)</em>);

</pre>
Note here that when we call the <em>walk()</em> function as a callback whenever
the user clicks the 'walk' button, <em>walk() automatically receives an argument
of 5</em>; the parameter <em>d</em> will be set equal to 5, so the cat will
walk 5 units of distance. The rule is that <em>arguments to bind() following the
context of "this" will become parameters to the specified callback function</em>.
</p>
<h2>Exercises</h2>
<p><strong>Write these using CommonJS modules. Use one module per class and write an
index.js file to act as the entry point for your application, which requires the module(s)
you need.</strong>
See <a href='modules.html'>here</a>.</p>
<p>Revisit your car scenario from Topics 8 and 9. Ensure you write your Car as a class.
Add additional methods to start and stop the engine (similar to the example
above) and ensure that <em>accelerate()</em> will only run if the engine is
running, otherwise display an error. Add buttons on your page to start and stop
the engine and accelerate and decelerate the car, and to display the current
car details. Connect these buttons to the appropriate methods of Car, ensuring
that you use <em>bind()</em> to preserve the context of <em>this</em>.</p>
<li><strong>This will require you to read up on key events, which is in the
further notes for Topic 10</strong> (see <a href='furtherevents.html'>here</a>).
Create a class representing a Hero in a game. It should have x and y coordinates,
and also an Image object, as properties. Give it a <em>display()</em> method.
The display() method should take a canvas <em>context</em> as a parameter and,
using the canvas context,
should draw the Hero at its current x and y coordinates. Also give the Hero
methods to move left, right, up and down, which should change x and y
appropriately. Connect this to a web page with a 
canvas, and using key events, move and display the hero in response to the arrow keys by calling the 
appopriate methods of the Hero.</p>
<h2>More advanced exercise - writing the Buy functionality using the DOM</h2>
<p>The first exercise was a simple approach to linking your search results to the Buy functionality. However the approach taken, of embedding the <code>buy()</code> call in your HTML, is rather messy as it mixes HTML and JavaScript and is not unobtrusive JavaScript. So this exercise allows you to rewrite it in a cleaner way using the DOM.</p>

<p>Make a copy, in a new file, of your existing HitTastic!  AJAX page. Delete all the existing code in the <em>forEach</em> arrow function and and replace it with the code below:</p>
<ol>
<li>Add code to <em>create a DOM paragraph (p) element</em>
for each song returned.</li>
<li>Within this <em>p</em>, create:
    <ul>
    <li>a text node containing the details of the song, and </li>
    <li>a button node (i.e. an 
    "input" with a type of "button") allowing the user to buy 
    the song. Add both to the paragraph node using <em>appendChild()</em>. 
    </li>
    </ul>
To make sure that the button is an input with a type of "button", you 
need to set the "type" property to "button", i.e. if <em>btn</em> is your 
button, then you can use: <pre>btn.type = "button";</pre>
</li>
<li>Specify the text on the button by setting the "value" property:
<pre>btn.value="Buy!";</pre>
</li>
<li>Set up a "click" event handler for the button. as an arrow function, e.g: 
<pre>
btn.addEventListener ("click", e =&gt; 
    { 
        // fill in your arrow function here.
        // It should call your "buy" web API route, passing in the ID of the current song.
    } 
);
</pre>
This will set the "click" handler of the button to be an arrow function.</li>
<li>Add each paragraph to the results div using <em>appendChild()</em>.</li>
<li>You can now complete the arrow function which runs when the user clicks
the button. Use AJAX to call the "buy" route of your web API.
You will need to call the web API using a method of POST (see above),
though in this case you will not need to send any FormData.
</li>
<li>
The callback to the AJAX buy request should 
display a "Successfully bought" message, e.g. in an alert box.</li>
<li>Add error handling to the "buy" route of your web API so that if the required song is out of stock (quantity is 0), a 404 is returned. You will need to add an additional SELECT statement for this to work.</li>
<li>Alter your AJAX front end to check for a 404 from the "buy" 
route of your web API. In the callback, display a different message
depending on whether the song was bought successfully or not.</li> 
<li><strong>More advanced:</strong> Alter your "buy" route to be able
to buy more than one copy of the song (receive the quantity as POST
data). Update your AJAX front end to allow the user to enter the quantity,
and send the entered quantity to the web service.
<strong>As this is an advanced question, I am leaving it up to you to figure
out how to do this</strong> but if you are really stuck, I will give you some
<em>hints</em>. However, as it's advanced I will not write it for you!</li>
</ol>
</body>
</html>
